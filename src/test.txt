
    pub async fn generate_block(
        &mut self,
	transactions: &mut Vec<Transaction>,
	previous_block: &Block,
        blockchain_lock: Arc<RwLock<Blockchain>>,
    ) -> Block {

        let blockchain = blockchain_lock.read().await;

        let previous_block_id = previous_block.get_id();
        let previous_block_hash = previous_block.get_hash();
        let previous_block_burnfee = previous_block.get_burnfee();
        let previous_block_timestamp = previous_block.get_timestamp();
        let previous_block_difficulty = blockchain.get_difficulty();

        let mut block = Block::new();

        let current_timestamp = create_timestamp();
        let current_burnfee: u64 =
            BurnFee::return_burnfee_for_block_produced_at_current_timestamp_in_nolan(
                previous_block_burnfee,
                current_timestamp,
                previous_block_timestamp,
            );

        block.set_id(previous_block_id + 1);
        block.set_previous_block_hash(previous_block_hash);
        block.set_burnfee(current_burnfee);
        block.set_timestamp(current_timestamp);
        block.set_difficulty(previous_block_difficulty);

        mem::swap(&mut block.transactions, &mut transactions);

	//
	// TODO - not ideal that we have to loop through the block.
	// perhaps we can put GT in a specific location.
	//
        for transaction in &block.transactions {
	    if transaction.is_golden_ticket() {
		block.set_has_golden_ticket(true);
		break;
	    }
	}

        //
        // create
        //
        let cv: DataToValidate = block.generate_data_to_validate(&blockchain);

	//
	// fee transactions and golden tickets
        //
        // set hash_for_signature for fee_tx as we cannot mutably fetch it
        // during merkle_root generation as those functions require parallel
        // processing in block validation. So some extra code here.
        //
        if !cv.fee_transaction.is_none() {

            //
            // fee-transaction must still pass validation rules
            //
            let mut fee_tx = cv.fee_transaction.unwrap();
            let wallet = self.wallet_lock.write().await;

            for input in fee_tx.get_mut_inputs() {
                input.set_publickey(wallet.get_publickey());
            }
            let hash_for_signature: SaitoHash = hash(&fee_tx.serialize_for_signature());
            fee_tx.set_hash_for_signature(hash_for_signature);

            //
            // sign the transaction and finalize it
            //
            fee_tx.sign(wallet.get_privatekey());

            block.add_transaction(fee_tx);
	    block.set_has_fee_transaction(true);

        }


	//
	// validate difficulty
	//
        if cv.expected_difficulty != 0 {
	    block.set_difficulty(cv.expected_difficulty);
        }

        let block_merkle_root = block.generate_merkle_root();
        block.set_merkle_root(block_merkle_root);
        let block_hash = block.generate_hash();
        block.set_hash(block_hash);

        let wallet = self.wallet_lock.read().await;
	block.sign(wallet.get_publickey(), wallet.get_privatekey());

        block
    }

